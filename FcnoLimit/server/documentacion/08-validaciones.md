# ‚úÖ Validaciones FCnoLimit

## üéØ Visi√≥n General
Sistema de validaciones centralizado que asegura la integridad de los datos en toda la aplicaci√≥n. Utiliza esquemas estructurados para validar entrada de usuarios, par√°metros de API y datos de base de datos.

## üèóÔ∏è Arquitectura de Validaciones

### **Capas de Validaci√≥n**
```
Frontend Validation ‚Üí API Validation ‚Üí Business Logic ‚Üí Database Constraints
```

### **Tipos de Validaci√≥n**
- **üîç Sint√°ctica**: Formato y estructura
- **üìä Sem√°ntica**: Reglas de negocio
- **üõ°Ô∏è Seguridad**: Prevenci√≥n de ataques
- **üóÑÔ∏è Integridad**: Consistencia de datos

## üîê Validaciones de Autenticaci√≥n

### **`/validations/authValidation.js`** - Usuario y Auth

#### **Esquema de Registro de Usuario**
```javascript
const Joi = require('joi');

/**
 * Validaci√≥n para registro de nuevo usuario
 */
const registerUserSchema = Joi.object({
  nombre_completo: Joi.string()
    .min(2)
    .max(100)
    .pattern(/^[a-zA-Z√°√©√≠√≥√∫√º√±√Å√â√ç√ì√ö√ú√ë\s]+$/)
    .required()
    .messages({
      'string.empty': 'El nombre completo es requerido',
      'string.min': 'El nombre debe tener al menos 2 caracteres',
      'string.max': 'El nombre no puede exceder 100 caracteres',
      'string.pattern.base': 'El nombre solo puede contener letras y espacios',
      'any.required': 'El nombre completo es obligatorio'
    }),

  correo: Joi.string()
    .email()
    .max(255)
    .lowercase()
    .required()
    .messages({
      'string.email': 'Debe proporcionar un email v√°lido',
      'string.max': 'El email no puede exceder 255 caracteres',
      'any.required': 'El email es obligatorio'
    }),

  contrase√±a: Joi.string()
    .min(8)
    .max(128)
    .pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/)
    .required()
    .messages({
      'string.min': 'La contrase√±a debe tener al menos 8 caracteres',
      'string.max': 'La contrase√±a no puede exceder 128 caracteres',
      'string.pattern.base': 'La contrase√±a debe contener al menos: 1 min√∫scula, 1 may√∫scula, 1 n√∫mero y 1 car√°cter especial',
      'any.required': 'La contrase√±a es obligatoria'
    }),

  rol: Joi.string()
    .valid('jugador', 'entrenador', 'persona_natural', 'administrador')
    .default('persona_natural')
    .messages({
      'any.only': 'El rol debe ser: jugador, entrenador, persona_natural o administrador'
    })
});

/**
 * Validaci√≥n para login de usuario
 */
const loginUserSchema = Joi.object({
  correo: Joi.string()
    .email()
    .required()
    .messages({
      'string.email': 'Debe proporcionar un email v√°lido',
      'any.required': 'El email es obligatorio'
    }),

  contrase√±a: Joi.string()
    .min(1)
    .required()
    .messages({
      'string.empty': 'La contrase√±a es requerida',
      'any.required': 'La contrase√±a es obligatoria'
    })
});

/**
 * Validaci√≥n para refresh token
 */
const refreshTokenSchema = Joi.object({
  refreshToken: Joi.string()
    .required()
    .messages({
      'string.empty': 'El refresh token es requerido',
      'any.required': 'El refresh token es obligatorio'
    })
});
```

#### **Validaciones Personalizadas**
```javascript
/**
 * Validador personalizado para verificar email √∫nico
 * @param {String} email - Email a verificar
 * @param {Object} pool - Conexi√≥n a base de datos
 * @returns {Promise<Boolean>} true si el email est√° disponible
 */
async function validateUniqueEmail(email, pool) {
  try {
    const result = await pool.query(
      'SELECT id FROM "fcnolimit".usuarios WHERE correo = $1',
      [email.toLowerCase()]
    );
    
    return result.rows.length === 0;
  } catch (error) {
    console.error('Error al validar email √∫nico:', error);
    throw new Error('Error al validar disponibilidad del email');
  }
}

/**
 * Validador de fortaleza de contrase√±a con scoring
 * @param {String} password - Contrase√±a a evaluar
 * @returns {Object} { score, feedback, isStrong }
 */
function validatePasswordStrength(password) {
  let score = 0;
  const feedback = [];

  // Longitud
  if (password.length >= 8) score += 1;
  else feedback.push('Usar al menos 8 caracteres');

  if (password.length >= 12) score += 1;

  // Complejidad
  if (/[a-z]/.test(password)) score += 1;
  else feedback.push('Incluir letras min√∫sculas');

  if (/[A-Z]/.test(password)) score += 1;
  else feedback.push('Incluir letras may√∫sculas');

  if (/\d/.test(password)) score += 1;
  else feedback.push('Incluir n√∫meros');

  if (/[@$!%*?&]/.test(password)) score += 1;
  else feedback.push('Incluir caracteres especiales (@$!%*?&)');

  // Patrones comunes (penalizaci√≥n)
  const commonPatterns = ['123456', 'password', 'qwerty', 'abc123'];
  if (commonPatterns.some(pattern => password.toLowerCase().includes(pattern))) {
    score -= 2;
    feedback.push('Evitar patrones comunes');
  }

  return {
    score: Math.max(0, score),
    feedback,
    isStrong: score >= 4,
    level: score >= 4 ? 'fuerte' : score >= 2 ? 'medio' : 'd√©bil'
  };
}
```

## ‚öΩ Validaciones de Entidades Deportivas

### **`/validations/equipoValidation.js`** - Equipos

#### **Esquema de Equipo**
```javascript
/**
 * Validaci√≥n para creaci√≥n/actualizaci√≥n de equipo
 */
const equipoSchema = Joi.object({
  nombre: Joi.string()
    .min(2)
    .max(100)
    .pattern(/^[a-zA-Z√°√©√≠√≥√∫√º√±√Å√â√ç√ì√ö√ú√ë0-9\s\-\.]+$/)
    .required()
    .messages({
      'string.min': 'El nombre del equipo debe tener al menos 2 caracteres',
      'string.max': 'El nombre no puede exceder 100 caracteres',
      'string.pattern.base': 'El nombre solo puede contener letras, n√∫meros, espacios, guiones y puntos',
      'any.required': 'El nombre del equipo es obligatorio'
    }),

  logo_url: Joi.string()
    .uri()
    .optional()
    .messages({
      'string.uri': 'La URL del logo debe ser v√°lida'
    }),

  fecha_fundacion: Joi.date()
    .max('now')
    .optional()
    .messages({
      'date.max': 'La fecha de fundaci√≥n no puede ser futura'
    }),

  estadio_id: Joi.number()
    .integer()
    .positive()
    .optional()
    .messages({
      'number.base': 'El ID del estadio debe ser un n√∫mero',
      'number.positive': 'El ID del estadio debe ser positivo'
    }),

  entrenador_id: Joi.number()
    .integer()
    .positive()
    .optional()
    .messages({
      'number.base': 'El ID del entrenador debe ser un n√∫mero',
      'number.positive': 'El ID del entrenador debe ser positivo'
    }),

  division_id: Joi.number()
    .integer()
    .positive()
    .required()
    .messages({
      'number.base': 'El ID de la divisi√≥n debe ser un n√∫mero',
      'number.positive': 'El ID de la divisi√≥n debe ser positivo',
      'any.required': 'La divisi√≥n es obligatoria'
    }),

  asociacion_id: Joi.number()
    .integer()
    .positive()
    .optional()
    .messages({
      'number.base': 'El ID de la asociaci√≥n debe ser un n√∫mero',
      'number.positive': 'El ID de la asociaci√≥n debe ser positivo'
    })
});
```

### **`/validations/jugadorValidation.js`** - Jugadores

#### **Esquema de Jugador**
```javascript
/**
 * Validaci√≥n para registro de jugador
 */
const jugadorSchema = Joi.object({
  user_id: Joi.number()
    .integer()
    .positive()
    .required()
    .messages({
      'number.base': 'El ID del usuario debe ser un n√∫mero',
      'number.positive': 'El ID del usuario debe ser positivo',
      'any.required': 'El usuario es obligatorio'
    }),

  equipo_id: Joi.number()
    .integer()
    .positive()
    .required()
    .messages({
      'number.base': 'El ID del equipo debe ser un n√∫mero',
      'number.positive': 'El ID del equipo debe ser positivo',
      'any.required': 'El equipo es obligatorio'
    }),

  numero_camiseta: Joi.number()
    .integer()
    .min(1)
    .max(99)
    .required()
    .messages({
      'number.base': 'El n√∫mero de camiseta debe ser un n√∫mero',
      'number.min': 'El n√∫mero de camiseta debe ser al menos 1',
      'number.max': 'El n√∫mero de camiseta no puede exceder 99',
      'any.required': 'El n√∫mero de camiseta es obligatorio'
    }),

  posicion: Joi.string()
    .valid(
      'portero', 
      'defensa_central', 
      'lateral_izquierdo', 
      'lateral_derecho',
      'mediocentro', 
      'mediocentro_defensivo', 
      'mediocentro_ofensivo',
      'extremo_izquierdo', 
      'extremo_derecho',
      'delantero_centro', 
      'segundo_delantero'
    )
    .required()
    .messages({
      'any.only': 'La posici√≥n debe ser una de las posiciones v√°lidas',
      'any.required': 'La posici√≥n es obligatoria'
    }),

  fecha_nacimiento: Joi.date()
    .max(new Date(Date.now() - 16 * 365 * 24 * 60 * 60 * 1000)) // M√≠nimo 16 a√±os
    .min(new Date(Date.now() - 50 * 365 * 24 * 60 * 60 * 1000)) // M√°ximo 50 a√±os
    .required()
    .messages({
      'date.max': 'El jugador debe tener al menos 16 a√±os',
      'date.min': 'El jugador no puede tener m√°s de 50 a√±os',
      'any.required': 'La fecha de nacimiento es obligatoria'
    }),

  altura: Joi.number()
    .precision(2)
    .min(1.40)
    .max(2.20)
    .optional()
    .messages({
      'number.min': 'La altura m√≠nima es 1.40m',
      'number.max': 'La altura m√°xima es 2.20m'
    }),

  peso: Joi.number()
    .precision(1)
    .min(40)
    .max(150)
    .optional()
    .messages({
      'number.min': 'El peso m√≠nimo es 40kg',
      'number.max': 'El peso m√°ximo es 150kg'
    }),

  pie_dominante: Joi.string()
    .valid('izquierdo', 'derecho', 'ambidiestro')
    .default('derecho')
    .messages({
      'any.only': 'El pie dominante debe ser: izquierdo, derecho o ambidiestro'
    })
});
```

## üèÜ Validaciones de Partidos y Estad√≠sticas

### **`/validations/partidoValidation.js`** - Partidos

#### **Esquema de Partido**
```javascript
/**
 * Validaci√≥n para creaci√≥n de partido
 */
const partidoSchema = Joi.object({
  equipo_local_id: Joi.number()
    .integer()
    .positive()
    .required()
    .messages({
      'any.required': 'El equipo local es obligatorio'
    }),

  equipo_visitante_id: Joi.number()
    .integer()
    .positive()
    .required()
    .not(Joi.ref('equipo_local_id'))
    .messages({
      'any.required': 'El equipo visitante es obligatorio',
      'any.invalid': 'El equipo visitante debe ser diferente al local'
    }),

  fecha_partido: Joi.date()
    .min('now')
    .required()
    .messages({
      'date.min': 'La fecha del partido debe ser futura',
      'any.required': 'La fecha del partido es obligatoria'
    }),

  estadio_id: Joi.number()
    .integer()
    .positive()
    .required()
    .messages({
      'any.required': 'El estadio es obligatorio'
    }),

  division_id: Joi.number()
    .integer()
    .positive()
    .required()
    .messages({
      'any.required': 'La divisi√≥n es obligatoria'
    }),

  goles_local: Joi.number()
    .integer()
    .min(0)
    .max(20)
    .default(0)
    .messages({
      'number.min': 'Los goles no pueden ser negativos',
      'number.max': 'M√°ximo 20 goles por equipo'
    }),

  goles_visitante: Joi.number()
    .integer()
    .min(0)
    .max(20)
    .default(0)
    .messages({
      'number.min': 'Los goles no pueden ser negativos',
      'number.max': 'M√°ximo 20 goles por equipo'
    }),

  estado: Joi.string()
    .valid('programado', 'en_curso', 'finalizado', 'cancelado')
    .default('programado')
    .messages({
      'any.only': 'El estado debe ser: programado, en_curso, finalizado o cancelado'
    })
});
```

### **`/validations/estadisticasJugadorPartidoValidation.js`** - Estad√≠sticas de Jugador

#### **Esquema de Estad√≠sticas**
```javascript
/**
 * Validaci√≥n para estad√≠sticas de jugador en partido
 */
const estadisticasJugadorPartidoSchema = Joi.object({
  jugador_id: Joi.number()
    .integer()
    .positive()
    .required()
    .messages({
      'any.required': 'El jugador es obligatorio'
    }),

  partido_id: Joi.number()
    .integer()
    .positive()
    .required()
    .messages({
      'any.required': 'El partido es obligatorio'
    }),

  goles: Joi.number()
    .integer()
    .min(0)
    .max(10)
    .default(0)
    .messages({
      'number.min': 'Los goles no pueden ser negativos',
      'number.max': 'M√°ximo 10 goles por jugador'
    }),

  asistencias: Joi.number()
    .integer()
    .min(0)
    .max(10)
    .default(0)
    .messages({
      'number.min': 'Las asistencias no pueden ser negativas',
      'number.max': 'M√°ximo 10 asistencias por jugador'
    }),

  tarjetas_amarillas: Joi.number()
    .integer()
    .min(0)
    .max(2)
    .default(0)
    .messages({
      'number.min': 'Las tarjetas amarillas no pueden ser negativas',
      'number.max': 'M√°ximo 2 tarjetas amarillas por jugador'
    }),

  tarjetas_rojas: Joi.number()
    .integer()
    .min(0)
    .max(1)
    .default(0)
    .messages({
      'number.min': 'Las tarjetas rojas no pueden ser negativas',
      'number.max': 'M√°ximo 1 tarjeta roja por jugador'
    }),

  minutos_jugados: Joi.number()
    .integer()
    .min(0)
    .max(120)
    .default(0)
    .messages({
      'number.min': 'Los minutos jugados no pueden ser negativos',
      'number.max': 'M√°ximo 120 minutos por partido (incluyendo tiempo extra)'
    })
}).custom((value, helpers) => {
  // Validaci√≥n cruzada: si tiene tarjeta roja, validar minutos jugados
  if (value.tarjetas_rojas > 0 && value.minutos_jugados === 0) {
    return helpers.error('any.custom', {
      message: 'Si el jugador tiene tarjeta roja debe haber jugado algunos minutos'
    });
  }
  
  // Validaci√≥n: no puede tener m√°s de 2 tarjetas amarillas si tiene roja
  if (value.tarjetas_rojas > 0 && value.tarjetas_amarillas > 1) {
    return helpers.error('any.custom', {
      message: 'No puede tener m√°s de 1 tarjeta amarilla si ya tiene roja'
    });
  }
  
  return value;
});
```

## üèõÔ∏è Validaciones de Entidades Organizacionales

### **`/validations/ligaValidation.js`** - Ligas y Campeonatos

#### **Esquema de Liga/Campeonato**
```javascript
/**
 * Validaci√≥n para creaci√≥n de liga/campeonato
 */
const ligaSchema = Joi.object({
  nombre: Joi.string()
    .min(3)
    .max(100)
    .required()
    .messages({
      'string.min': 'El nombre de la liga debe tener al menos 3 caracteres',
      'string.max': 'El nombre no puede exceder 100 caracteres',
      'any.required': 'El nombre de la liga es obligatorio'
    }),

  fecha_inicio: Joi.date()
    .min('now')
    .required()
    .messages({
      'date.min': 'La fecha de inicio debe ser futura',
      'any.required': 'La fecha de inicio es obligatoria'
    }),

  fecha_fin: Joi.date()
    .min(Joi.ref('fecha_inicio'))
    .required()
    .messages({
      'date.min': 'La fecha de fin debe ser posterior a la fecha de inicio',
      'any.required': 'La fecha de fin es obligatoria'
    }),

  division_id: Joi.number()
    .integer()
    .positive()
    .required()
    .messages({
      'any.required': 'La divisi√≥n es obligatoria'
    }),

  max_equipos: Joi.number()
    .integer()
    .min(4)
    .max(32)
    .default(16)
    .messages({
      'number.min': 'M√≠nimo 4 equipos en una liga',
      'number.max': 'M√°ximo 32 equipos en una liga'
    }),

  estado: Joi.string()
    .valid('planificado', 'inscripciones_abiertas', 'en_curso', 'finalizado')
    .default('planificado')
    .messages({
      'any.only': 'El estado debe ser: planificado, inscripciones_abiertas, en_curso o finalizado'
    })
});
```

## üîç Middleware de Validaci√≥n

### **`/middlewares/validate.js`** - Aplicar Validaciones

#### **Middleware Universal**
```javascript
const Joi = require('joi');

/**
 * Middleware para validar request body con esquemas Joi
 * @param {Object} schema - Esquema Joi de validaci√≥n
 * @param {String} source - Fuente de datos: 'body', 'query', 'params'
 * @returns {Function} Middleware function
 */
function validate(schema, source = 'body') {
  return (req, res, next) => {
    const data = req[source];
    
    const { error, value } = schema.validate(data, {
      abortEarly: false, // Retornar todos los errores
      stripUnknown: true, // Remover campos no definidos
      convert: true // Convertir tipos autom√°ticamente
    });

    if (error) {
      const errors = error.details.map(detail => ({
        field: detail.path.join('.'),
        message: detail.message,
        value: detail.context.value
      }));

      return res.status(400).json({
        error: 'Datos de entrada inv√°lidos',
        code: 'VALIDATION_ERROR',
        details: errors,
        timestamp: new Date().toISOString()
      });
    }

    // Reemplazar datos originales con datos validados y sanitizados
    req[source] = value;
    next();
  };
}

/**
 * Middleware para validaciones personalizadas as√≠ncronas
 * @param {Function} customValidator - Funci√≥n de validaci√≥n personalizada
 * @returns {Function} Middleware function
 */
function validateAsync(customValidator) {
  return async (req, res, next) => {
    try {
      const isValid = await customValidator(req);
      
      if (!isValid) {
        return res.status(400).json({
          error: 'Validaci√≥n personalizada fallida',
          code: 'CUSTOM_VALIDATION_ERROR',
          timestamp: new Date().toISOString()
        });
      }
      
      next();
    } catch (error) {
      console.error('Error en validaci√≥n personalizada:', error);
      return res.status(500).json({
        error: 'Error interno en validaci√≥n',
        code: 'VALIDATION_INTERNAL_ERROR',
        timestamp: new Date().toISOString()
      });
    }
  };
}

module.exports = {
  validate,
  validateAsync
};
```

#### **Uso de Middlewares de Validaci√≥n**
```javascript
// En las rutas
const { validate } = require('../middlewares/validate');
const { registerUserSchema, loginUserSchema } = require('../validations/authValidation');

// Validaci√≥n de registro
router.post('/register', 
  validate(registerUserSchema), 
  async (req, res) => {
    // req.body ya est√° validado y sanitizado
    const user = await createUser(pool, req.body);
    res.status(201).json({ data: user });
  }
);

// Validaci√≥n de query parameters
router.get('/equipos', 
  validate(equiposQuerySchema, 'query'), 
  async (req, res) => {
    // req.query ya est√° validado
    const equipos = await getEquipos(pool, req.query);
    res.json({ data: equipos });
  }
);

// Validaci√≥n personalizada as√≠ncrona
router.post('/equipos',
  validate(equipoSchema),
  validateAsync(async (req) => {
    // Verificar que la divisi√≥n existe
    const division = await pool.query('SELECT id FROM divisiones WHERE id = $1', [req.body.division_id]);
    return division.rows.length > 0;
  }),
  async (req, res) => {
    const equipo = await createEquipo(pool, req.body);
    res.status(201).json({ data: equipo });
  }
);
```

## üìä Validaciones de Integridad de Datos

### **Validaciones Cruzadas**
```javascript
/**
 * Validador para verificar que un jugador no est√© en m√∫ltiples equipos
 */
async function validateJugadorUniqueTeam(userId, equipoId, pool) {
  const result = await pool.query(
    'SELECT equipo_id FROM "fcnolimit".jugadores WHERE user_id = $1 AND equipo_id != $2',
    [userId, equipoId]
  );
  
  if (result.rows.length > 0) {
    throw new Error('El jugador ya pertenece a otro equipo');
  }
  
  return true;
}

/**
 * Validador para verificar n√∫mero de camiseta √∫nico en el equipo
 */
async function validateUniqueJerseyNumber(equipoId, numeroCamiseta, jugadorId, pool) {
  let query = 'SELECT id FROM "fcnolimit".jugadores WHERE equipo_id = $1 AND numero_camiseta = $2';
  let params = [equipoId, numeroCamiseta];
  
  if (jugadorId) {
    query += ' AND id != $3';
    params.push(jugadorId);
  }
  
  const result = await pool.query(query, params);
  
  if (result.rows.length > 0) {
    throw new Error('El n√∫mero de camiseta ya est√° en uso en este equipo');
  }
  
  return true;
}
```

## üõ°Ô∏è Validaciones de Seguridad

### **Sanitizaci√≥n y Prevenci√≥n de Ataques**
```javascript
/**
 * Sanitizador para prevenir XSS
 * @param {String} input - Texto a sanitizar
 * @returns {String} Texto sanitizado
 */
function sanitizeHtml(input) {
  if (typeof input !== 'string') return input;
  
  return input
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;')
    .replace(/\//g, '&#x2F;');
}

/**
 * Validador para prevenir SQL injection en b√∫squedas
 * @param {String} searchTerm - T√©rmino de b√∫squeda
 * @returns {Boolean} true si es seguro
 */
function validateSearchTerm(searchTerm) {
  // Prevenir caracteres peligrosos
  const dangerousChars = /[;'"\\]/;
  if (dangerousChars.test(searchTerm)) {
    return false;
  }
  
  // Limitar longitud
  if (searchTerm.length > 100) {
    return false;
  }
  
  return true;
}
```

---

## üöÄ Pr√≥ximas Mejoras de Validaciones

1. **Schema Versioning** - Versionado de esquemas
2. **Dynamic Validation** - Validaciones basadas en contexto
3. **Bulk Validation** - Validaci√≥n de arrays grandes
4. **Real-time Validation** - Validaci√≥n en tiempo real
5. **Custom Error Messages** - Mensajes personalizados por idioma
6. **Performance Optimization** - Cache de esquemas compilados

---
*√öltima actualizaci√≥n: $(new Date().toLocaleDateString())*
